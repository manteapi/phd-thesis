\section{Continuum mechanics}

Continuum mechanics allows to define general equations of motion for a wide range of phenomena from liquids to deformable solids. 
In this section, we propose a progressive introduction to the basics of continuum mechanics and provide details about the physical models used in the following chapters.
Firstly, we describe how to formulate general equations of motion and we present the different concepts and numerical tools used to solve them.
Secondly, we present a constitutive law for fluid mechanics leading to the Navier-Stokes equations and we detail their discretization using the Smoothed-Particle Hydrodynamics (SPH) model that will serve as background for our contribution in Chapter~\ref{chap:arps}.
Finally, we present a constitutive law for solid mechanics which allows to simulate elastic solds and we detail the discretization of the equations of motion using the frame-based model that we use in Chapter~\ref{chap:cutting}.
%\subsection{Notation}
%
%We will use the following notations throughout this manuscript.
%\begin{table}[!h]
%\begin{tabular}{ll}
%$t$ & time \\
%$m$ &  mass \\
%$\rho$ & mass density \\
%$\mathbf{n}$ & normal \\
%$\mathbf{x}$ & position \\
%$\mathbf{v}$ & velocity \\
%$\mathbf{f}$ & total forces \\
%$\mathbf{f}_{int}$ & internal forces \\
%$\mathbf{f}_{ext}$ & external forces \\
%$\mathbf{F}$ & Deformation gradient \\
%$\epsilon$ & Strain tensor \\
%$\sigma$ & Stress tensor \\
%$\Psi$ & Energy density \\
%\end{tabular}
%\end{table}

\subsection{Equations of motion}

The equations of motion describes the behavior of an object over time.
They are generally derived from conservation laws such as mass and momentum conservation. 
A constitutive law is also used to depict the intrinsic behavior of the simulated object.
The remainder of this section first describes the conservation laws used to formulate general equations of motion.
Then we details the concepts and numerical tools used to solve these equations.

\subsubsection{Conservation of mass}

\begin{figure}[!h]
\centering
\includegraphics[scale=0.8]{images/continuum_mechanics/massConservation.png}
\caption[STAR mechanics: Mass conservation]{\label{fig:massConservation} Mass conservation. $M(t_{1}) = M(t_{0}) + M_{in} + M_{out}$}
\end{figure}

The conservation of mass is quite explicit. 
Whatever the physical material which is studied, mass cannot be created or destroyed. 
If we look at a small volume $\mathcal{V}$ of the domain $\Omega$, the variation of mass in $\mathcal{V}$ should be equal to the flux of mass going through the border of the volume.

\begin{equation}
    \label{eq:massConservation}
    \displaystyle 
    \frac{d}{dt}\left( \int_{\mathcal{V}} \rho dv \right)
    =
    - \int_{\mathcal{\partial V}}\rho \mathbf{v} \cdot \mathbf{n} ds
\end{equation}

From Stokes' formula, we have

\begin{equation}
\displaystyle 
\int_{\partial \mathcal{V}} \rho \mathbf{v} \cdot \mathbf{n} ds =
\int_{\mathcal{V}} \nabla \cdot \left( \rho \mathbf{v} \right) dv =
\int_{\mathcal{V}} \nabla \rho \cdot \mathbf{v} dv
\end{equation}

then the conservation of mass can be rewritten as

\begin{equation}
\label{eq:volumetricMassConservation}
\displaystyle \int_{\mathcal{V}} \frac{d}{dt} \rho + \nabla \cdot \left( \rho  \mathbf{v} \right) dv = 0
\end{equation}

\subsubsection{Conservation of momentum}

\begin{figure}[!ht]
\centering
\includegraphics[scale=1.5]{images/continuum_mechanics/momentumConservation.png}
\caption[STAR mechanics: Momentum conservation]{\label{fig:momentumConservation} Momentum conservation.}
\end{figure}

Also called Newton's second law, it states:
\begin{equation}
\label{eq:momentumConservation}
\displaystyle \int_{\mathcal{V}} \rho \frac{d}{dt} \mathbf{v}(t,x) dv = \int_{\mathcal{V}} \mathbf{f} dv
\end{equation}

Two kind of forces are generally applied on an object, the \emph{external} forces and the \emph{internal} forces.

External forces describe the action of the surrounding environment on the object. 
The simplest example is weight:
\begin{equation}
\displaystyle \int_{\mathcal{V}} \rho \mathbf{g} dv
\end{equation}

Internal forces describe the reaction of the object to an external deformation. A general way to describe them is by using the stress tensor notation. In the following, we will describe the constitutive laws for incompressible fluids (section \ref{subsec:fluidMechanics}) and solids (section \ref{subsec:solidMechanics}).
\begin{equation}
\displaystyle \int_{\partial \mathcal{V}} \sigma \mathbf{n} ds
\end{equation}
By applying the Stokes' formula we can describe it with respect to the volume:
\begin{equation}
\displaystyle 
\int_{\mathcal{\partial V}} \sigma \mathbf{n} ds =
\int_{\mathcal{V}} \nabla \cdot \sigma dv
\end{equation}

Conservation of momentum can then be rewritten:
\begin{equation}
\label{eq:volumetricMomentumConservation}
\displaystyle
\int_{\mathcal{V}} \rho \frac{D}{Dt} \mathbf{v}(t,x) dx = \int_{\mathcal{V}} \rho \mathbf{g} + \nabla. \sigma dx
\end{equation}

\subsubsection{Lagrangian vs. Eulerian formulations}

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.5]{images/continuum_mechanics/eulerianVsLagrangian.png}
\caption[STAR mechanics: Eulerian vs. Lagrangian]{\label{fig:EulerianVsLagrangian} Eulerian vs. Lagrangian viewpoint}
\end{figure}

A simulation can be seen from two viewpoints. To illustrate this we can take the example of a river that we simulate (see Figure~\ref{fig:EulerianVsLagrangian}). From this simulation we want to measure the velocity of the flow. A first possibility is to discretized the river into particles that will carry and update fluid properties such as position and velocity. This is the Lagrangian viewpoint. A second possibility is to discretize the river on a fixed grid from where we can measure the velocity of the flow passing through a point of the grid. This is the Eulerian viewpoint.

From a mathematical perspective this can be expressed in the material derivative formula. Let's compute the total derivative of a quantity $\mathbf{u}$ which depends on time $t$ and location $\mathbf{x}$. By using the derivation chain rule, we have:
\begin{equation}
\frac{d}{dt}\mathbf{u}(t,\mathbf{x}) = 
\frac{\partial \mathbf{u}}{\partial t} + \nabla \mathbf{u} \cdot \frac{d\mathbf{x}}{dt} =
\frac{\partial \mathbf{u}}{\partial t} + \nabla \mathbf{u} \cdot \mathbf{v} 
\end{equation}
In this equation, the expression $\frac{\partial \mathbf{u}}{\partial t}$ is the derivative at fixed point, the Eulerian derivative. Now if the location $\mathbf{x}$ is the position of a particle, then the total derivative is called the material or Lagrangian derivative and measures the derivative for the particle location $\mathbf{x}$.

Notice that equation~(\ref{eq:volumetricMassConservation}) can be rewritten in a Lagrangian way by detailing the divergence of the product between density and velocity:
\begin{equation}
\label{eq:lagrangianMassConservation}
\int_{\mathcal{V}} \frac{D\rho}{Dt} + \rho \nabla \cdot \mathbf{v} dv = 0
\end{equation}

In Lagrangian simulations, conservation of mass is guaranteed by assuming that the mass of the particles are constant over time. In this context, numerically solving of equation~(\ref{eq:lagrangianMassConservation}) can be omitted. It is worth to notice that in Lagrangian liquid simulations, conservation of the mass does not imply incompressibility. To insure the latter, equation~(\ref{eq:lagrangianMassConservation}) needs to be revisited and integrated within the numerical solver. An approach to enforce incompressibility was recently proposed for SPH simulations by Bender and Koschier~\cite{Bender2015}.

\subsubsection{Numerical solving}

Once the equations of motion are stated, they are discretized in space an time in order to be numerically solved.

\paragraph{Spatial discretization}

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.2]{images/continuum_mechanics/discretization.png}
\caption[STAR mechanics: Discretization]{\label{fig:discretization} On the left a grid discretization, commonly used in Eulerian simulations. In the middle an unstructured mesh discretization, commonly used in mesh-based Lagrangian simulations. On the right, a point-based discretization, commonly used in mesh-less Lagrangian simulations.}
\end{figure}

The spatial discretization consists in approximating the object to simulate using a finite number of samples. Then by using an interpolation method, it is possible to approximate continuous quantities such as position, velocity, density and so on,  at any location on the domain. Finally, a quadrature rule is needed in order to integrate these quantities over the domain. These are the main components for solving the equations of motion:
degrees of freedom, an interpolation method and a quadrature rule. 

Multiple possibilities exist for these components. It is crucial to choose them based on the constraints of the simulation, What do we want to measure ? How will boundaries be represented ? Will any topological changes occur ? Have we restrictions in terms of computational or memory cost ? In the following we briefly introduce the solutions the most commonly used in Computer Graphics.

\subparagraph{Degrees of freedom}
For Eulerian simulations, velocities are the most common degrees of freedom. Usually they are computed at fixed regularly sampled locations, which allow to accurately compute derivatives. For Lagrangian simulations, positions are the most common degrees of freedom. They can sample the object in many different ways depending on the interpolation method. Another possibility is to also represent orientations, this is used, for instance, in the frame-based model where degrees of freedom are affine frames.

\subparagraph{Interpolation}

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.5]{images/continuum_mechanics/shapefunction.png}
\caption[STAR mechanics: Shape functions]{\label{fig:shapefunction} Three examples of shape functions. Each color represents the shape function associated to one degrees of freedom (black circle). On the left, shape functions for trilinear interpolation are illustrated. In the middle, barycentric shape functions are illustrated. On the right, kernel-based shape functions that are used in SPH and Moving Least Square interpolation are illustrated.}
\end{figure}

As mentioned above, interpolation is used to continuously approximate the physical quantities over the domain such as density, displacement, pressure and so on. In Computer Graphics, we can distinguish three major interpolation methods: linear interpolation, moving least squares and SPH interpolation. For each of them different weights, also called \emph{shape functions} can be used (see Figure~\ref{fig:shapefunction}). 

The choice of the interpolation method is closely related to the spatial sampling of the degrees of freedom. Usually two types of sampling are distinguished: mesh-based sampling and mesh-less sampling (see Figure~\ref{fig:discretization}).

In mesh-based methods, the degrees of freedom are the vertices of a mesh. Depending on its structure different possibilities exist. For grids, trilinear interpolation is often used. For unstructured meshes, linear interpolation with barycentric weights is the most popular choice.

In mesh-less methods, the sampling of degrees of freedom might be completely unstructured. For Lagrangian fluids, particles of fluid will often change of neighborhood, the structure is quasi-inexistent For Lagrangian elastic solids, particles will keep the same neighborhood as long as the object does not undergo topological changes. The two most common interpolation methods are SPH and Moving Least Squares. Weights are often computed using cubic kernel. However if the sampling of degrees of freedom is very sparse, Voronoi-based shape functions are a good alternative.

\subparagraph{Spatial Integration}

\begin{figure}[!ht]
\centering
\includegraphics[scale=1.0]{images/continuum_mechanics/spatialIntegration.png}
\caption[STAR mechanics: Spatial integration]{\label{fig:spatialIntegration} Illustration of the midpoint rule. The integration domain is partitioned into uniform regions $\left[x_{i}, x_{i+1}\right]$, an integration point $x'_{i}$ is sampled at the center of each partition and the function is only evaluated at the location of the integration points.}
\end{figure}

Over the simulation, different physical quantities, for instance density or internal forces, need to be integrated over the domain. There is need for a quadrature rule. Many exists, most of the time the simple midpoint rule is chosen. The domain is decomposed in a partition, where each partition has an associated volume $V_{i}$. Points $\mathbf{x}_{i}$ are sampled at the center of each partitions, they are called \emph{integration points}. Then the integral of a function $f$ over a domain $\Omega$ states as:
\begin{equation}
\label{eq:midpointRule}
\int_{V} f(x) = \sum_{i} V_{i}f(\mathbf{x}_{i})
\end{equation}

Figure~\ref{fig:spatialIntegration} depicts the midpoint rule for a one dimensional function.

In mesh-based methods, it is common to consider one integration point at the center of each element and integrate over the volume of the element.
In mesh-less methods, when the sampling of the degrees of freedom is dense, integration points are often co-located with the degrees of freedom and integrated over their associated volume. However, when the sampling is sparse, an independent sampling of integration points is used to have a finer integration.

\paragraph{Temporal integration}

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.6]{images/continuum_mechanics/timeIntegration.png}
\caption[STAR mechanics: Temporal integration]{\label{fig:timeIntegration} Illustration of a 1D forward Euler temporal integration.}
\end{figure}

Once physical quantities have been spatially integrated, they can be integrated over time. 

\begin{equation}
\label{eq:timeIntegration1}
\displaystyle
\int_{t_{n}}^{t_{n+1}}
\rho \frac{d\mathbf{v}}{dt}
=
\int_{t_{n}}^{t_{n+1}}\mathbf{f}
\end{equation}

Many integrations scheme can be used. Most of them can be explained simply by the Taylor expansion.

\begin{equation}
\label{eq:taylorExpansion}
\displaystyle
f(x) = \sum_{k=0}^{n}\frac{\left(x-a\right)^{k}}{k!}f^{(k)}(a) + \int_{a}^{x}\frac{\left(x-t\right)^{n}}{n!}f^{(n+1)}(t)dt
\end{equation}

Applied to equation (\ref{eq:timeIntegration1}), this gives:

\begin{equation}
\label{eq:timeIntegration2}
\displaystyle
\mathbf{v}(t_{n+1}) = \mathbf{v}(t_{n}) + \int_{t_{n}}^{t_{n+1}}\frac{1}{\rho}\frac{d\mathbf{v}}{dt}
\end{equation}

This expression can be further expanded in order to get more accurate result. In Computer Graphics, this is the most used expansion. Generally, the integral term is computed with the rectangle quadrature rule.

For a left rectangle method, we get an explicit integration of the velocity:
\begin{equation}
\label{eq:explicitIntegration}
\mathbf{v}(t_{n+1}) = \mathbf{v}(t_{n}) + \left(t_{n+1}-t_{n}\right) \frac{\mathbf{f}(t_{n})}{\rho}
\end{equation}

For a right rectangle method, we get an implicit integration of the velocity:
\begin{equation}
\label{eq:implicitIntegration}
\mathbf{v}(t_{n+1}) = \mathbf{v}(t_{n}) + \left(t_{n+1}-t_{n}\right) \frac{\mathbf{f}(t_{n+1})}{\rho}
\end{equation}

The same rule applies for the integration of other physical quantities. In a Lagrangian system, both velocity and position needs to be integrated. There are mainly three different schemes that are used in Computer Graphics: forward Euler, symplectic Euler and backward Euler.

Forward Euler is the explicit integration of both position and velocity:
\begin{equation}
\label{eq:explicitEuler}
\begin{array}{l}
\displaystyle \mathbf{x}(t+\Delta t) = \mathbf{x}(t) + \Delta t \mathbf{v}(t) \\ \\
\displaystyle \mathbf{v}(t+\Delta t) = \mathbf{v}(t) + \Delta t \frac{\mathbf{f(t)}}{\rho}(t)
\end{array}
\end{equation}

Symplectic Euler is the explicit integration of velocity and implicit integration of position:
\begin{equation}
\label{eq:symplecticEuler}
\begin{array}{l}
\displaystyle \mathbf{v}(t+\Delta t) = \mathbf{v}(t) + \Delta t \frac{\mathbf{f}(t)}{\rho} \\ \\
\displaystyle \mathbf{x}(t+\Delta t) = \mathbf{x}(t) + \Delta t \mathbf{v}(t+\Delta t)
\end{array}
\end{equation}

Backward Euler is the implicit integration of both position and velocity
\begin{equation}
\label{eq:backwardEuler}
\begin{array}{ll}
\displaystyle \mathbf{v}(t+\Delta t) = \mathbf{v}(t) + \Delta t \frac{\mathbf{f}(t)}{\rho}(t+\Delta t) \\ \\
\displaystyle \mathbf{x}(t+\Delta t) = \mathbf{x}(t) + \Delta t \mathbf{v}(t+\Delta t)
\end{array}
\end{equation}

Forward and symplectic Euler are among the easiest integration schemes. They are cheap and easy to implement. However stability is guaranteed for a restricted range of time steps. Implicit Euler is more expensive as it results in solving an equation. However unconditional stability is guaranteed which means that large time steps can be used resulting in a significant speed-up of the simulation.

A nice way to solve the equation of backward Euler is to expand the force expression in order to fall back to solving a linear system. There, efficient iterative methods such as the conjugate gradient can be used.

\subsection{Fluid mechanics}
\label{subsec:fluidMechanics}

\subsubsection{Constitutive Law}

A fluid mainly reacts to pressure and viscosity and thus the constitutive law can be written as:
\begin{equation}
\label{eq:fluidConstitutiveLaw}
\sigma = -pI + \eta \left( \nabla \mathbf{v} + \nabla \mathbf{v}^{T} \right)
\end{equation}

Then we have:
\begin{equation}
\nabla \cdot \sigma = \nabla \cdot \left( -pI + \eta \left( \nabla \mathbf{v} + \nabla \mathbf{v}^{T} \right) \right) = -\nabla p + \Delta \mathbf{v}
\end{equation}

Additionally, the fluid might be incompressible, such as water, which means that the mass should not vary over time. In this case, the conservation of mass can be rewritten as:
\begin{equation}
\nabla \cdot \mathbf{v} = 0
\end{equation}

Finally, by injecting equation~(\ref{eq:fluidConstitutiveLaw}) in equation~(\ref{eq:volumetricMomentumConservation}), this gives us the Navier-Stokes equation for an incompressible fluid:

\begin{equation}
\left\lbrace
\begin{array}{ll}
\displaystyle
\int_{\mathcal{V}} \rho \frac{D}{Dt} \mathbf{v}(t,x) dx = 
\int_{\mathcal{V}} \rho \mathbf{g} -\nabla p + \eta \Delta \mathbf{v} dx \\ \\
\displaystyle
\nabla. \mathbf{v} = 0
\end{array}
\right.
\end{equation}

\subsubsection{Smoothed Particles Hydrodynamics model}
\label{subsubsec:starSPH}
Smoothed Particles Hydrodynamics (SPH) is an interpolation method that can be used to approximate the Navier-Stokes equation in a Lagrangian way. The fluid is discretized into particles which represent small volumes of the whole fluid and each quantity is interpolated using SPH.

\paragraph{SPH interpolation}
The interpolation of a function $f$ at a position $\mathbf{x}$ is :
\begin{equation}
f(\mathbf{x}) = \int_{V} f(\mathbf{x'})W(\mathbf{x}-\mathbf{x'}, h)dx'
\end{equation}
where $W$ is a function called \emph{kernel}. 

If the fluid is discretized into particles with a mass $m$, a density $\rho$ and a volume $V$, then we can discretize the SPH interpolation as:
\begin{equation}
f(\mathbf{x}) = \sum_{p} f(\mathbf{x}_{p})V_{p} W(\mathbf{x}-\mathbf{x_{p}},h) = \sum_{p} f(\mathbf{x}_{p})\frac{m_{p}}{\rho_{p}} W(\mathbf{x}-\mathbf{x_{p}},h)
\end{equation}

Derivatives can be computed and discretized the same way:
\begin{equation}
D^{\alpha} f(\mathbf{x}) = \int_{\mathcal{V}} f(\mathbf{x'}) D^{\alpha} W(\mathbf{x}-\mathbf{x'}, h)dx'
\end{equation}

\begin{equation}
D^{\alpha} f(\mathbf{x})= \sum_{p} f(\mathbf{x}_{p})\frac{m_{p}}{\rho_{p}} D^{\alpha} W(\mathbf{x}-\mathbf{x_{p}},h)
\end{equation}

However, for first derivatives, the approximation does not vanish if $f$ is constant. A quick way to ensure that is to use a differentiable function $\Phi$ (in practice we use the density $\rho$) to re-write the derivative using the derivative of a product :
\begin{equation}
\label{eq:hackSPH}
\nabla f(x) = \frac{1}{\Phi}\left(\nabla (f \Phi) - f \nabla \Phi \right)
\end{equation}

\paragraph{How to choose the kernel}
The properties of $W$ can vary with respect to the properties of the function to be interpolated. In general, $W$ meet the following properties:
\begin{itemize}
\item $W$ is normalized. Thus, constants are interpolated exactly.
\item $W$ has a compact support.
\begin{equation}
\parallel \mathbf{x} \parallel \geq h \rightarrow W(\mathbf{x},h) = 0 
\end{equation}
\begin{equation}
\int_{\mathcal{V}} W(\mathbf{x},h) dx = 1
\end{equation}
\item $W$ tend to the delta function when the length scale $h$ tends to $0$.
\begin{equation}
\lim_{h \rightarrow 0} W(x,h) = \delta(x)
\end{equation}
\item $W$ should be symmetric to enforce invariance under rotation
\begin{equation}
W(-x,h) = W(x,h)
\end{equation}
\item Depending on the function to interpolate the kernel should be positive to prevent unphysical interpolated value.
\begin{equation}
W \geq 0
\end{equation}
\end{itemize}

The cubic kernel from Monaghan~\cite{Monaghan2005} is a good choice in practice.

\paragraph{Applications to Navier-Stokes}

\begin{equation}
\label{eq:densitySPH}
\rho_{i} = \sum_{j} m_{j}W(\mathbf{x_{i}}-\mathbf{x_{j}},h)
\end{equation}

\begin{equation}
\left(\nabla p\right)_{i} = \sum_{j} \frac{m_{j}}{\rho_{j}} p_{j} \nabla W(\mathbf{x_{i}}-\mathbf{x_{j}},h)
\end{equation}

However linear and angular momentum are not conserved as the formula is not symmetric. By using equation~(\ref{eq:hackSPH}) with $\displaystyle \Phi = \frac{1}{\rho}$, it can be symmetrized:

\begin{equation}
\label{eq:pressureGradientSPH}
\left(\nabla p\right)_{i} = 
\frac{1}{\rho_{i}}
\sum_{j} m_{j} \left( \frac{p_{i}}{\rho_{i}^{2}} + \frac{p_{j}}{\rho_{j}^{2}} \right) \nabla W(\mathbf{x_{i}}-\mathbf{x_{j}},h)
\end{equation}

\begin{equation}
\left(\Delta \mathbf{v}\right)_{i} = \sum_{j} \frac{m_{j}}{\rho_{j}} \mathbf{v}_{j} \Delta W(\mathbf{x_{i}}-\mathbf{x_{j}},h)
\end{equation}

Same as for the pressure gradient, this is not symmetric. Here it can be symmetrized by using $\Phi = \rho$.

\begin{equation}
\left(\Delta \mathbf{v}\right)_{i} = \frac{1}{\rho_{i}}\sum_{j} m_{j} \left( \mathbf{v}_{j}-\mathbf{v}_{i}\right) \Delta W(\mathbf{x_{i}}-\mathbf{x_{j}},h)
\end{equation}

In practice, the evaluation of the laplacian is not accurate. Another form of viscosity based on the gradient was proposed by Monaghan~\cite{Monaghan2005}. This is still an area of research.

\begin{equation}
\label{eq:velocityLaplacianSPH}
\left(\Delta \mathbf{v}\right)_{i} = 
\frac{1}{\rho_{i}}
\sum_{j} m_{j} \Pi_{ij} \nabla W(\mathbf{x_{i}}-\mathbf{x_{j}},h)
\end{equation}

where 

\begin{equation}
    \Pi_{ij} = -\frac{2hc_{s}}{\rho_{i}+\rho_{j}}\frac{\mathbf{v}_{ij}^{T}\mathbf{x}_{ij}}{\vert \mathbf{x}_{ij} \vert^{2} + \epsilon h^{2}}
\end{equation}

Pressure can be computed by a spring-like equation:
\begin{equation}
\label{eq:pressureSPH}
p_{i} = k\left(\rho_{i}-\rho_{0}\right)
\end{equation}
where $k$ is a stiffness parameter. Even though it is simple and cheap, reaching incompressibility requires very small time step because of the stiffness parameter. Recently, new techniques were proposed to compute pressure so that the fluid would be incompressible. We do not detail these methods in this thesis but refer the reader to the work of Ihmsen et al.~\cite{Ihmsen2014:IISPH} and Bender and Koschier~\cite{Bender2015}.

Now if we discretize Navier-Stokes for one particle $i$, we have:

\begin{equation}
    \displaystyle m_{i}\frac{d}{dt}\mathbf{v}_{i}(t) = m_{i}\mathbf{g} - \frac{m_{i}}{\rho_{i}}(\nabla p)_{i} + \eta\frac{m_{i}}{\rho_{i}}\left(\Delta \mathbf{v}\right)_{i}
\end{equation}

This equation can now be discretized in time and integrated. In practice we use the Euler symplectic integrator:

\begin{equation}
\begin{array}{ll}
\displaystyle \mathbf{v}_{i}(t+\Delta t) = \mathbf{v}_{i}(t) + \Delta t \frac{d}{dt}\mathbf{v}_{i}(t) \\ \\
\displaystyle \mathbf{x}_{i}(t+\Delta t) = \mathbf{x}_{i}(t) + \Delta t \mathbf{v}_{i}(t+\Delta t)
\end{array}
\end{equation}

We described the key ingredient of the SPH model and how to use them to discretize Navier-Stokes equations. There is not enough space to cover the exciting challenges related to the building of a full SPH simulator. For a robust handling of static and dynamic boundaries, a surface tension model and an efficient surface reconstruction pipeline, we refer to the work of Akinci et al.~\cite{Akinci2012b, Akinci2013, Akinci2012a}.  For a state of the art of optimization techniques for SPH, we refer the reader to the work of Ihmsen et al.~\cite{Ihmsen2011:ParallelSPH}. For other references related to the handling of viscosity, multi-phase simulations and other problems, the state of the art report on SPH by Ihmsen et al.~\cite{Ihmsen2014:STAR} is a safe starting point.

\subsection{Solid mechanics}
\label{subsec:solidMechanics}

\begin{figure}[!ht]
\centering
\includegraphics[scale=0.4]{./images/continuum_mechanics/displacementField.png}
\caption[STAR mechanics: Displacement field]{\label{fig:displacementField}
 The displacement field $\Phi$ maps each point $\mathbf{X}$ from the rest configuration $\Omega_{0}$ to a point $\mathbf{x}$ in the deformed configuration $\Omega$.}
\end{figure}

In this section, we focus on the simulation of elastic objects. When submitted to external forces, an elastic object reacts so that it comes back to its rest shape. In contrast with fluids, internal forces are history dependent, they depend on how much the object deformed compared to its rest shape. It becomes crucial to be able to describe the deformation of an object in order to express its reaction. 

The deformation is modeled by a mapping $\Phi$ between the undeformed configuration $\Omega_{0}$ and the deformed configuration $\Omega$. $\Phi$ is called the \emph{displacement field}.
\begin{equation}
\begin{array}{lllll}
\Phi & : & \Omega_{0} & \longrightarrow & \Omega \\
	 &  & \mathbf{X} & \longrightarrow & \mathbf{x}
\end{array}
\end{equation}
where $\mathbf{X}$ is a point in the undeformed configuration and $\mathbf{x}=\Phi(\mathbf{X})$ is the mapped point into the deformed configuration.

The deformation gradient $\displaystyle \mathbf{F} = \frac{\partial \Phi}{\partial \mathbf{X}}$ measures deformation with respect to the undeformed configuration. The strain tensor $\epsilon$ measures how the object has derived from its undeformed configuration. There exist different strain measures, Green-Lagrange strain can be used for instance: $\displaystyle \epsilon = \frac{1}{2}\left(\mathbf{F}^{T}\mathbf{F} - \mathbf{I}\right)$. Or its linearized version, the Cauchy strain $\displaystyle \epsilon = \frac{1}{2}\left( \mathbf{F} + \mathbf{F}^{T} \right)-\mathbf{I}$.

The displacement field, deformation gradient and strain tensor are the main components of the constitutive law that will relate the deformation to the material properties of the object.

\subsubsection{Constitutive Law}
A common way to describe the stress tensor $\sigma$ for elastic materials is to use a constitutive density energy $\Psi$ and to derive it with respect to the strain tensor $\epsilon$:
\begin{equation}
\sigma = \frac{\partial \Psi}{\partial \epsilon}
\end{equation}

Different forms of energy exist. For a classical Hookean material, the density energy is
\begin{equation}
\Psi = \frac{1}{2}H\epsilon^{2}
\end{equation}

Then the stress tensor is
\begin{equation}
\sigma = H\epsilon
\end{equation}

H is called the stiffness tensor and is a $3\times3\times3\times3$ tensor. For isotropic materials, the number of material parameters can be reduced to two, the Young's modulus $E$ and the Poisson's ratio $\nu$. Also, the strain and stress tensor being symmetric, the constitutive law can be simplified:
\begin{equation}
\sigma = 
\begin{bmatrix}
\sigma_{11} \\
\sigma_{22} \\
\sigma_{33} \\
\sigma_{23} \\
\sigma_{13} \\
\sigma_{12}
\end{bmatrix}
=
\tilde{H}
\begin{bmatrix}
\epsilon_{11} \\
\epsilon_{22} \\
\epsilon_{33} \\
2\epsilon_{23} \\
2\epsilon_{13} \\
2\epsilon_{12}
\end{bmatrix}
\end{equation}

where

\begin{equation}
\tilde{H} =
\frac{E}{\left(1+\nu\right)\left(1-2\nu\right)}
\begin{bmatrix}
1-\nu & \nu & \nu & 0 & 0 & 0 \\ 
\nu & 1-\nu & \nu & 0 & 0 & 0 \\
\nu & \nu & 1-\nu & 0 & 0 & 0 \\
0 & 0 & 0 & \frac{1-2\nu}{2} & 0 & 0 \\
0 & 0 & 0 & 0 & \frac{1-2\nu}{2} & 0 \\
0 & 0 & 0 & 0 & 0 & \frac{1-2\nu}{2} \\
\end{bmatrix}
\end{equation}

Instead of computing internal forces as the divergence of the stress, they can be computed as the derivative of the density energy with respect to the degrees of freedom:
\begin{equation}
\label{eq:internalForces}
\mathbf{f} = -\int_{\mathcal{V}} \frac{\partial \Psi}{\partial \mathbf{x}}^{T} dv
\end{equation}

\subsubsection{Frame-based model}

The frame-based model was introduced by Gilles et al.~\cite{Gilles2011} to simulate deformable objects. In contrast to other deformable models, it allows to simulate complex object with very few degrees of freedom and to handle heterogeneous materials easily \cite{Faure2011}. Additionally, this work formalized the concept of multi-layer physical framework. In the following, we first describe what is a multi-layer framework, illustrate it in the case of the frame-based model. Then we detail a standard choice for the different components of the frame-based model: degrees of freedom, interpolation and integration. As in the previous section, we do not detail collision detection and response process as well as a more accurate formulation of viscosity via the strain rate.

\paragraph{A multi-layer physical framework}
 
\begin{figure}[!ht]
\centering
\includegraphics[scale=0.6]{./images/continuum_mechanics/multiLayeredFramework.png}
\caption[STAR mechanics: Multi-layer framework]{\label{fig:multiLayerFramework} Each component of the simulation is isolated and communicates with other components through mapping. By doing so, the framework allows fast prototyping and comparison of a wide range of deformable models.}
\end{figure}

Most of the time, the different components of a physics-based model are described as a monolithic framework: degrees of freedom, interpolation, integration and constitutive law are put together in one formula which computes the forces applied on the degrees of freedom. On one hand, this provides a compact and implementation-friendly expression. It also suits the short format of scientific article. On the other hand, it requires assumptions on each component and make it hard to distinguish what should be changed in order to integrate collisions, to embed a visual model or to test variations of the initial model.

An interesting alternative is to build a multi-layer framework where each component of a physics-based model represents a layer which is able to communicate with other layers by using mappings. The framework has then a great modularity, different components can be re-used and mixed. A direct consequence is the ease at prototyping. State of the art methods can be implemented in hours instead of days. Comparisons of different models is much easier. Also, it provides a way to control the granularity of a simulation. As each layer can be discretized at its own resolution, it allows for an easier repartition of resources and computational task.

In their work, Gilles et al. \cite{Gilles2011} proposed such an alternative by decomposing the computation of force using the derivation chain rule:
\begin{equation}
\label{eq:forceChainRule}
\displaystyle \mathbf{f} = -\int_{V} \left(\frac{\partial \Psi}{\partial \mathbf{x}}\right)^{T} dv
=
-\int_{V} \left(\frac{\partial \mathbf{F}}{\partial \mathbf{x}}\right)^{T}
\left(\frac{\partial \epsilon}{\partial \mathbf{F}}\right)^{T}
\left(\frac{\partial \Psi}{\partial \epsilon}\right)^{T} dv
\end{equation}
We can now distinguish the different layers: the degrees of freedom, the deformation gradient, the strain tensor and the constitutive density energy. We can also distinguish the Jacobian of the mappings that link degrees of freedom to deformation gradient, deformation gradient to strain and strain to constitutive density energy. Layers and mappings can be implemented separately thus providing a great deal of modularity. Moreover it is straightforward to have a sampling of degrees of freedom different from the sampling of integration points that will be used to compute deformation gradient, strain and stress.

In the case of the frame-based method, there are two additional layers, one for embedding a visual model and one for handling collisions. Both communicates with the degrees of freedom through a mapping which is the displacement field (see Figure~\ref{fig:multiLayerFramework}).

\paragraph{Degrees of freedom}
The object is uniformly sampled with affine frames as degrees of freedom. An affine frames $T=(\mathbf{A},\mathbf{t})$ represents $12$ degree of freedoms, $3$ for translation $\mathbf{t}$, $9$ for the matrix $\mathbf{A}$ combining rotation, scaling and shearing. Affine frames are represented with respect to an initial configuration ~$T_{0} = \left(\mathbf{A_{0}}, \mathbf{t_{0}}\right)$.

\paragraph{Interpolation}
Linear blend skinning is used to interpolate the displacement field and other quantities of the simulation. A deformed position $\mathbf{x}$ can be interpolated as a weighted sum of the affine transformations applied to the rest position $\mathbf{x_{0}}$.

\begin{equation}
\begin{array}{l}
\displaystyle \mathbf{x} = \sum_{i} w_{i}(\mathbf{x_{0}})\left(\mathbf{t_{i}}+\mathbf{A_{i}}\mathbf{x_{0}}^{rel}\right) \\
\displaystyle \mathbf{x_{0}}^{rel} = \mathbf{A_{0}}^{-1}\left( \mathbf{x_{0}} - \mathbf{t_{0}} \right)
\end{array}
\end{equation}

where $\mathbf{x_{0}^{rel}}$ is the relative position of $x_{0}$ in the frame defined by $T_{0}$ and $w_{i}$ is the shape function associated to the frame $i$.

Different weights can be used. Three properties are important in order to represent a physical behavior. First, the shape function should linearly decrease with respect to distance in the material. Otherwise, the deformation will not be uniform with respect to the distance from the frame. Second, the shape function should be positive. Third, the weights should form a partition of unity. In practice, one can use harmonic weights or Voronoi-based weights which are described later.

From the description of the displacement field, the deformation gradient can then be derived:
\begin{equation}
\displaystyle
\mathbf{F}\left(\mathbf{x}\right) = \sum_{i} \frac{\partial \mathbf{x}}{\partial \mathbf{x_{0}}} =
\nabla w_{i}(\mathbf{x_{0}}) \left( \mathbf{t_{i}}+\mathbf{A_{i}}\mathbf{x_{0}}^{rel}\right) + 
w_{i}\left( \mathbf{A_{i}}\mathbf{A_{0}}^{-1} \right)
\end{equation}

\paragraph{Spatial integration}

Any quadrature rule can be used. Here, for the sake of simplicity, we suppose that we use the midpoint rule briefly described in Figure~\ref{fig:spatialIntegration}. Thus, the integral of a function $f$ over the object states:
\begin{equation}
\displaystyle
\int_{V} f(x)  = \sum_{i} V_{i} f(x_{i})
\end{equation}
where $i$ is an integration point and $V_{i}$ its associated volume.

From this quadrature rule, we can now explicit the computation of internal forces for one frame:
\begin{equation}
\label{eq:frameForceComputation}
\displaystyle
\mathbf{f}_{i} =
- \sum_{p}
\left( \frac{\partial \mathbf{F}}{\partial \mathbf{x}_{i}} \right)^{T}
\left( \frac{\partial \epsilon}{\partial \mathbf{F}} \right)^{T}
\left( \frac{\partial \Psi}{\partial \mathbf{\epsilon}} \right)^{T} \left(\mathbf{x_{p}}\right) V_{p} 
\end{equation}
where $p$ is an integration point, $\mathbf{x}_{p}$ its position and $V_{p}$ its associated volume.

\paragraph{Temporal integration}

Assuming the mass matrix is lumped and that we use explicit Euler, the time integration of one frame $i$ is:
\begin{equation}
\displaystyle
\begin{pmatrix}
\mathbf{t_{i}}(t+\Delta t) \\
\mathbf{A_{i}}(t+\Delta t)
\end{pmatrix} 
=
\begin{pmatrix}
\mathbf{t_{i}}(t) \\
\mathbf{A_{i}}(t)
\end{pmatrix} 
+
\Delta t
\mathbf{M}_{i}^{-1}
\mathbf{f}(t)
\end{equation}
where $\mathbf{M}_{i}$ is the mass matrix of the frame $i$:
\begin{equation}
\label{eq:massMatrix}
\mathbf{M}_{i} = \int_{V} w_{i}^{T} \rho w_{i}
\end{equation}
and $w_{i}$ is the shape function of the frame $i$.

\subsection{Conclusion on continuum mechanics}

Continuum mechanics allows to automatically compute realistic motion from a wide range of phenomena.
Due to this strength, hand-made animations of physical phenomena have been replaced by physics-based animation.
However, realism comes with a high computational cost.
This cost may make large scale simulations intractable or prevent from simulating advanced phenomena in interactive context.
In the following section, we review adaptive models, a common approach to make simulations efficient.
